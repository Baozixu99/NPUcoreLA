#### **1.1** 进程管理

进程管理模块主要功能有：进程初始化、进程载入和解析、进程切换、进程状态构建模块。下面分别介绍。

##### 1.1.1 进程控制块

进程指的是在系统中运行的一个程序的实例。而进程的生命周期包括从创建，就绪，阻塞，运行中，退出。在一个进程被创建之后，他会进入NPUcoreLA中的就绪队列，在被操作系统调度之后将会进入到运行状态。在运行状态下时间片耗尽或者是主动让出CPU的时候，进程会进入到就绪队列中，等待下一次被调度。在运行的时候调用诸如wait等系统调用，进程会进入到阻塞队列中，等待被唤醒。当进程执行结束，他会退出，释放系统资源。

在 NPUcoreLA 中，我们使用 TCB结构体来描述一个进程，该结构体可以完整地描述一个进程的内容和结构。利用该结构体，我们可以像linux 一样使用进程来模拟线程。这与 windows操作系统的设计思路是不同的，其线程的实现依靠单独的一套thread\_control\_block完成。

因此线程在 NPUcoreLA中的理解变为了这样——一个可以与同线程组(tg1d 共享内存空间的进程即为线程。

进程控制包括进程的创建、结束和信号处理。


-   exit: 结束调用它的进程。

-   exit\_group: 结束与调用进程相同进程组的所有进程。

-   kill: 向指定进程发送信号。

-   tkill: 向指定线程发送信号。

-   clone: 创建一个新进程，是 Linux 线程创建的基础。

-   execve: 在当前进程中加载并运行一个新程序。

-   wait4: 等待进程状态发生变化。

-   setpgid: 设置进程组 ID。

-   getpgid: 获取指定进程的进程组 ID。

在操作系统内核中，进程的生命周期从创建（New）阶段开始。在这个阶段，系统为进程分配所需的资源并初始化其内部数据结构。创建完成后，进程会被加入到就绪队列（Ready Queue），表示该进程已经准备好等待CPU的调度。当CPU空闲时，调度器会从就绪队列中选择一个进程，将其状态从 Ready 转变为 Running。此时，进程获得了CPU的使用权，开始执行其程序代码。在运行过程中，进程可能会因为等待某个输入输出（IO）事件而进入阻塞（Blocked）状态。在阻塞状态下，进程会释放CPU的使用权，并被移到等待队列中，直至特定事件发生。一旦阻塞条件解除，进程会被唤醒（Woken），并重新加入就绪队列中，等待再次调度。当进程完成任务或遇到错误导致终止时，进入退出（Exit）状态，释放占用的资源，并通知操作系统进行清理。进程的生命周期如图所示。

![进程管理](picture_进程管理/进程.png)

如下图所示，以下是 NPUcoreLA 进程管理模块的结构图。context.rs 文件定义了任务上下文的结构体以及其初始化方法；elf.rs 用于处理 ELF 文件信息。manager.rs 实现了任务管理器、等待队列和超时等待池，这些构成了进程调度的核心模块。mod.rs 作为进程管理模块的总接口，提供给其他模块使用，并负责加载初始进程。pid.rs 管理进程标识符、资源分配器和内核栈，并实例化了全局 PID 分配器和内核栈分配器，构成了进程创建的基础。processor.rs 文件定义了当前进程信息的类型和方法，并实例化了全局的当前进程信息 PROCESSOR，使其他模块能够执行当前进程并获取相关信息。switch.rs 和 switch.S 共同提供了进程切换的汇编实现。task.rs 定义了进程控制块（TCB）及其相关操作，在 NPUcoreLA 中，使用 TCB 这一名称替代 PCB 来同时表示进程控制块和线程控制块。threads.rs 则定义了 Futex 构件，用于维护多线程。接下来将详细介绍进程管理的核心数据结构，以便更好地理解 NPUcoreLA的进程管理实现。

![进程管理](picture_进程管理/进程管理.png)

如下图所示，TCB 记录了操作系统运行所需的全部关键信息，包括进程状态、CPU现场信息、程序和数据的起始地址等。TCB 是操作系统中最重要的数据结构之一，其存在使程序成为独立的运行单元。操作系统通过 TCB 感知和管理进程，并依据 TCB 中的相关信息进行调度。除此之外，TCB 还支持进程间的同步与通信，是多道程序环境下进程管理和调度的核心基础。

![进程管理](picture_进程管理/TCB结构.png)

基于时间片的轮转：如果操作系统给每个运行的进程的运行时间是一个足够 小的时间片（time slice），时间片一到，就抢占当前进程并切换到另外一个进程进行执 行。这样进程以时间片为单位轮流占用处理器执行。对于交互式进程而言，就有比较大 的机会在较短时间内执行，从而有助于减少响应时间。这种调度策略称为时间片轮转 （Round-Robin，RR）调度，基本思路即从就绪队列头取出一个进程，让他运行一个时间 片，然后把它放回队列尾，再从队列头取下一个进程执行，周而复始。

![进程管理](picture_进程管理/时间片轮转.png)

管理进程时，NPUcoreLA 使用了 TCB 的数据结构，不同于传统的 PCB 数据结构，NPUcoreLA 将线程视为共享栈的进程。TCB 的数据结构如下：

> ![进程管理](picture_进程管理/进程管理1.png) 

在上面的定义中，我们可以看到 TCB 中包含了进程的进程号，线程号，线程组号，内核栈，用户栈，退出信号以及一些共享的资源。后面将具体讲解如何管理这些资源以及进程之间的调度。

在 NPUcoreLA中，任务控制块 TCB(Task Control Block) 将直接作为 PCB进行使用。

下图是 NPUcoreLA 中进程控制块的具体组成。

> ![进程管理](picture_进程管理/进程管理2.png) 

##### 1.1.2 进程管理重要数据结构

\(1) 进程标识符PidHandle

同一时间存在的所有进程都有一个唯一的进程标识符，将其抽象为PidHandle 类型。

> ![进程管理](picture_进程管理/进程管理3.png) 

进程标识符是一个 64 位的无符号整数，用来标识进程ID。进程标识符的分配和回收由标识符分配器 RecycleAllocator完成。我们一般简称其为 PID。

\(2) 内核栈 KernelStack

内核在创建进程的时候，在创建 task\_struct 的同时，会为进程创建两个栈，第一个栈也就是上面分析到的进程用户栈，存在于用户空间使用，另外还有一个内核栈，存放在内核空间。

内核栈存在的意义：如系统调用在陷入内核后，系统调用中也是存在函数调用和自动变量，这些都需要栈支持。

每个进程都要有独自的内核栈的必要性：所有进程在运行时，都有可能通过系统调用陷入内核态继续执行，假设第一个进程陷入内核执行的时候，需要等待某个资源，主动schedule() ，让出 CPU，第二个进程假设也通过系统调用进入了内核态，如果进程共享内核栈，那么第二个进程在系统调用压栈时会破坏第一个进程栈数据。

每个应用都有自己的内核栈，因此 KernelStack 的内部就是其所属进程的PID 号。

> ![进程管理](picture_进程管理/进程管理4.png) 
